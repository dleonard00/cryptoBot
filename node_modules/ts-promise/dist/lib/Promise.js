"use strict";
/**
 * Promise implementation in TypeScript.
 *
 * Copyright (C) 2015 Martin Poelstra
 * License: MIT
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
/* tslint:disable:no-unused-expression */ // prevent errors on `trace && trace(....)`
// TODO:
// - remove all "called = true"-type code in resolvers, replace by single check in _resolve()/_reject()
// - add possibility for an unhandled-rejections-handler
// - try to remove mangling of Error's .stack property on rejections with longTraces enabled
var async_1 = require("./async");
var util_1 = require("./util");
var Trace_1 = require("./Trace");
var BaseError_1 = require("./BaseError");
/**
 * Thrown when a rejected promise is explicitly terminated with `.done()`.
 */
var UnhandledRejectionError = /** @class */ (function (_super) {
    __extends(UnhandledRejectionError, _super);
    function UnhandledRejectionError(reason, trace) {
        var _this = _super.call(this, "UnhandledRejectionError", "unhandled rejection: " + reason) || this;
        _this.reason = reason;
        // TODO: Find a better way to merge the location of `.done()` in the
        // trace, because nobody will look for this property...
        _this.trace = trace;
        // In case we have a reason, and it has a stack: use it instead of our
        // own stack, as it's more helpful to see where the original error was
        // thrown, than where it was thrown inside the promise lib.
        // In case we don't have a stack, explicitly state so, to not let people
        // chase a problem in the promise lib that isn't there...
        var stack = _this.reason && typeof _this.reason === "object" && _this.reason.stack;
        if (typeof stack !== "string") {
            stack = String(reason);
        }
        _this.stack = "UnhandledRejectionError: " + stack;
        return _this;
    }
    return UnhandledRejectionError;
}(BaseError_1.default));
exports.UnhandledRejectionError = UnhandledRejectionError;
var trace = undefined;
var longTraces = false;
var State;
(function (State) {
    State[State["Pending"] = 0] = "Pending";
    State[State["Fulfilled"] = 1] = "Fulfilled";
    State[State["Rejected"] = 2] = "Rejected";
})(State || (State = {}));
function internalResolver(fulfill, reject) {
    /* no-op, sentinel value */
}
internalResolver(undefined, undefined); // just for code coverage...
function noop() {
    /* no-op */
}
var getThenError = {
    error: undefined,
};
function wrapNonError(a) {
    // This is basically a marker for the places where we need to check
    // handling of errors for .error() support.
    // A no-op for now.
    return a;
}
var dummyDoneTrace = new Trace_1.default();
/**
 * Currently unwrapping promise, while running one of its then-callbacks.
 * Used to set the source of newly created promises.
 * We guarantee that at most one callback of a then() is running at any time.
 */
var unwrappingPromise = undefined;
var promiseIdCounter = 0;
/**
 * Fast, robust, type-safe promise implementation.
 */
var Promise = /** @class */ (function () {
    /**
     * Create new Promise.
     *
     * Pass a callback that will receive a `resolve()` and `reject()` function
     * to seal the promise's fate.
     *
     * @param  resolver Called with resolve and reject functions
     */
    function Promise(resolver) {
        var _this = this;
        this._id = promiseIdCounter++;
        this._state = 0 /* Pending */;
        this._result = undefined; // Can be fulfillment value or rejection reason
        this._handlers = undefined;
        this._trace = undefined;
        trace && trace(this, "construct");
        if (longTraces) {
            this._trace = new Trace_1.default(Promise);
            if (unwrappingPromise) {
                this._setSource(unwrappingPromise);
            }
        }
        if (resolver === internalResolver) {
            // Internally created promises pass 'internalResolver', signalling
            // that resolving will be done by calling private methods on the
            // Promise. This saves having to create 2 closures.
            return;
        }
        if (typeof resolver !== "function") {
            throw new TypeError("Promise resolver is not a function");
        }
        var called = false;
        try {
            resolver(function (y) {
                if (called) {
                    // 2.3.3.3.3: If both `resolvePromise` and `rejectPromise` are called,
                    // or multiple calls to the same argument are made, the first call
                    // takes precedence, and any further calls are ignored.
                    return;
                }
                // 2.3.3.3.1: If/when `resolvePromise` is called with value `y`,
                // run `[[Resolve]](promise, y)`
                called = true;
                _this._resolve(y);
            }, function (r) {
                if (called) {
                    // 2.3.3.3.3: If both `resolvePromise` and `rejectPromise` are called,
                    // or multiple calls to the same argument are made, the first call
                    // takes precedence, and any further calls are ignored.
                    return;
                }
                // 2.3.3.3.2: If/when `rejectPromise` is called with reason `r`,
                // reject `promise` with `r`
                called = true;
                _this._reject(wrapNonError(r));
            });
        }
        catch (e) {
            // 2.3.3.3.4: If calling `then` throws an exception `e`,
            // 2.3.3.3.4.1: If `resolvePromise` or `rejectPromise` have been called, ignore it.
            if (!called) {
                // 2.3.3.3.4.2: Otherwise, reject `promise` with `e` as the reason.
                called = true;
                this._reject(wrapNonError(e));
            }
        }
    }
    /**
     * Run either `onFulfilled` or `onRejected` callbacks when the promise is
     * resolved. Returns another promise for the return value of such a
     * callback.
     *
     * The callback will always be called at most once, and always
     * asynchronously (i.e. some time after e.g. the `resolver` passed to the
     * constructor has resolved the promise).
     *
     * Any error thrown or rejected promise returned from a callback will cause
     * the returned promise to be rejected with that error.
     *
     * If either or both callbacks are missing, the fulfillment or rejection is
     * passed on unmodified.
     *
     * Use `.catch(onRejected)` instead of `.then(undefined, onRejected)` for
     * stronger typing, better readability, and more functionality (predicates).
     *
     * @param onFulfilled Callback called with promise's fulfillment
     *                    value iff promise is fulfilled. Callback can return
     *                    another value or promise for a value.
     * @param onRejected  Optional callback called with promise's rejection
     *                    reason iff promise is rejected. Callback can return
     *                    another value or promise for a value.
     * @return Promise for value returned by either of the callbacks
     */
    Promise.prototype.then = function (onFulfilled, onRejected) {
        trace && trace(this, "then(" + typeof onFulfilled + ", " + typeof onRejected + ")");
        if (this._state === 1 /* Fulfilled */ && typeof onFulfilled !== "function" ||
            this._state === 2 /* Rejected */ && typeof onRejected !== "function") {
            // Optimization: handler is short-circuited, so pass the result (value/rejection)
            // through unmodified.
            // The typecast is safe, because we either have a fulfillment value
            // but no handler that could change the type, or a rejection without a
            // handler that could change it, so R === T in this case.
            // TODO: verify whether longTraces etc still work as expected
            return this;
        }
        // Construct new Promise, but use subclassed constructor, if any
        var slave = new (Object.getPrototypeOf(this).constructor)(internalResolver);
        slave._setSource(this);
        this._enqueue(onFulfilled, onRejected, slave, undefined);
        return slave;
    };
    /**
     * Run either `onFulfilled` or `onRejected` callbacks when the promise is
     * resolved. If the callback throws an error or the returned value resolves
     * to a rejection, the library will (asynchronously) throw an
     * `UnhandledRejectionError` with that error.
     *
     * The callback will always be called at most once, and always
     * asynchronously (i.e. some time after e.g. the `resolver` passed to the
     * constructor has resolved the promise).
     *
     * @param onFulfilled Optional callback called with promise's fulfillment
     *                    value iff promise is fulfilled. Any error thrown or
     *                    rejection returned will cause an UnhandledRejectionError
     *                    to be thrown.
     * @param onRejected  Optional callback called with promise's rejection
     *                    reason iff promise is rejected. Any error thrown or
     *                    rejection returned will cause an UnhandledRejectionError
     *                    to be thrown.
     */
    Promise.prototype.done = function (onFulfilled, onRejected) {
        trace && trace(this, "done(" + typeof onFulfilled + ", " + typeof onRejected + ")");
        if (this._state === 1 /* Fulfilled */ && typeof onFulfilled !== "function") {
            return;
        }
        var doneTrace = dummyDoneTrace;
        if (longTraces) {
            doneTrace = new Trace_1.default();
            if (this._trace) {
                doneTrace.setSource(this._trace);
            }
        }
        this._enqueue(onFulfilled, onRejected, undefined, doneTrace);
    };
    /**
     * Catch only errors that match predicate in case promise is rejected.
     * Predicate can be an Error (sub-)class, array of Error classes, or a
     * function that can return true to indicate a match.
     *
     * The returned promise is resolved with the output of the callback, so it
     * is possible to re-throw the error, but also to return a 'replacement'
     * value that should be used instead.
     *
     * @param predicate   Optional Error class, array of Error classes or match
     *                    function
     * @param onRejected  Callback called with promise's rejection reason iff
     *                    promise is rejected. Callback can return another value
     *                    or promise for a value.
     * @return Promise for original value, or 'replaced' value in case of error
     */
    Promise.prototype.catch = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        if (arguments.length === 1) {
            var onRejected = arguments[0];
            return this.then(undefined, onRejected);
        }
        else {
            var predicate_1 = arguments[0];
            var onRejected_1 = arguments[1];
            return this.then(undefined, function (reason) {
                var match = false;
                if (typeof predicate_1 === "function") {
                    if (predicate_1.prototype instanceof Error || predicate_1 === Error) {
                        match = reason instanceof predicate_1;
                    }
                    else {
                        match = predicate_1(reason);
                    }
                }
                else if (Array.isArray(predicate_1)) {
                    for (var i = 0; i < predicate_1.length; i++) {
                        if (reason instanceof predicate_1[i]) {
                            match = true;
                            break;
                        }
                    }
                }
                else {
                    throw new TypeError("invalid predicate to .catch(), got " + typeof predicate_1);
                }
                if (match) {
                    return onRejected_1(reason);
                }
                return Promise.reject(reason);
            });
        }
    };
    /**
     * Asynchronous equivalent of try { } finally { }.
     *
     * Runs `handler` when promise resolves (fulfilled or rejected).
     * Handler is passed the current promise (which is guaranteed to be
     * resolved), and can be interrogated with e.g. `isFulfilled()`, `.value()`,
     * etc.
     *
     * When `handler` returns `undefined` or its promise is fulfilled, the
     * promise from `finally()` is resolved to the original promise's resolved
     * value or rejection reason.
     * If `handler` throws an error or returns a rejection, the result of
     * `finally()` will be rejected with that error.
     *
     * Example:
     * someLenghtyOperation().finally((result) => {
     *   if (result.isFulfilled()) {
     *     console.log("succeeded");
     *   } else {
     *     console.log("failed", result.reason());
     *   }
     * });
     *
     * @param  handler [description]
     * @return promise with same value/reason as this one, after `handler`'s
     *         result (if any) has been fulfilled, or a promise rejected with
     *         `handler`'s error if it threw one or returned a rejection.
     */
    Promise.prototype.finally = function (handler) {
        var _this = this;
        var runner = function () { return handler(_this); };
        return this.then(runner, runner).return(this);
    };
    /**
     * @return `true` when promise is fulfilled, `false` otherwise.
     */
    Promise.prototype.isFulfilled = function () {
        return this._state === 1 /* Fulfilled */;
    };
    /**
     * @return `true` when promise is rejected, `false` otherwise.
     */
    Promise.prototype.isRejected = function () {
        return this._state === 2 /* Rejected */;
    };
    /**
     * @return `true` when promise is pending (may be resolved to another pending
     *         promise), `false` otherwise.
     */
    Promise.prototype.isPending = function () {
        return this._state === 0 /* Pending */;
    };
    /**
     * @return Fulfillment value if fulfilled, otherwise throws an error.
     */
    Promise.prototype.value = function () {
        if (!this.isFulfilled()) {
            throw new Error("Promise is not fulfilled");
        }
        return this._result;
    };
    /**
     * @return Rejection reason if rejected, otherwise throws an error.
     */
    Promise.prototype.reason = function () {
        if (!this.isRejected()) {
            throw new Error("Promise is not rejected");
        }
        return this._result;
    };
    /**
     * @return A human-readable representation of the promise and its status.
     */
    Promise.prototype.inspect = function () {
        return this.toString();
    };
    /**
     * @return A human-readable representation of the promise and its status.
     */
    Promise.prototype.toString = function () {
        var state;
        switch (this._state) {
            case 0 /* Pending */:
                state = "pending";
                break;
            case 1 /* Fulfilled */:
                state = "fulfilled";
                break;
            case 2 /* Rejected */:
                state = "rejected";
                break;
            /* istanbul ignore next */
            default: state = "unknown";
        }
        return "[Promise " + this._id + ": " + state + "]";
    };
    /**
     * Create a promise that resolves with the same value of this promise, after
     * `ms` milliseconds. The timer will start when the current promise is
     * resolved.
     * If the current promise is rejected, the resulting promise is also
     * rejected, without waiting for the timer.
     *
     * @param ms Number of milliseconds to wait before resolving
     * @return Promise that fulfills `ms` milliseconds after this promise fulfills
     */
    Promise.prototype.delay = function (ms) {
        return this.then(function (value) {
            return new Promise(function (resolve) {
                setTimeout(function () { return resolve(value); }, ms);
            });
        });
    };
    /**
     * Return a promise that resolves to `value` after this promise is
     * fulfilled.
     * Returned promise is rejected if this promise is rejected.
     *
     * Equivalent to `.then(() => value)`.
     *
     * @param value Value or promise for value of returned promise
     * @return Promise resolved to value after this promise fulfills
     */
    Promise.prototype.return = function (value) {
        if (value === undefined) {
            // In TypeScript, we often need to 'force' a promise to become a
            // void promise, so this is a common case. Prevents the closure.
            // (Note: the any cast is just because TS assumes were going to
            // return an R, but we're in fact going to return a void.)
            return this.then(noop);
        }
        return this.then(function () { return value; });
    };
    /**
     * Return a promise that is rejected with `reason` after this promise is
     * fulfilled.
     * If this promise is rejected, returned promise will rejected with that
     * error instead.
     *
     * Equivalent to `.then(() => { throw value; })`.
     *
     * @param reason Error reason to reject returned promise with
     * @return Promise rejected with `reason` after this promise fulfills
     */
    Promise.prototype.throw = function (reason) {
        return this.then(function () { return Promise.reject(reason); });
    };
    /**
     * Create an immediately resolved promise (in case of a 'normal' value), or
     * a promise that 'follows' another `Thenable` (e.g. a Promise from another
     * library).
     *
     * @param value Value (or Thenable for value) for returned promise
     * @return Promise resolved to `value`
     */
    Promise.resolve = function (value) {
        var p = new Promise(internalResolver);
        p._resolve(value);
        return p;
    };
    /**
     * Create an immediately rejected promise.
     *
     * Note: to create a rejected promise of a certain type, use e.g.
     * `Promise.reject<number>(myError)`
     *
     * @param reason Error object to set rejection reason
     * @return Promise resolved to rejection `reason`
     */
    Promise.reject = function (reason) {
        var p = new Promise(internalResolver);
        p._reject(reason);
        return p;
    };
    /**
     * Return a promise for an array of all resolved input promises (or values).
     * If any of the input promises is rejected, the returned promise is
     * rejected with that reason.
     * When passing an empty array, the promises is immediately resolved to an
     * empty array.
     *
     * @param thenables Array of values or promises for them
     * @return promise that resolves with array of all resolved values
     */
    Promise.all = function (thenables) {
        return new Promise(function (resolve, reject) {
            util_1.assert(Array.isArray(thenables), "thenables must be an Array");
            if (thenables.length === 0) {
                resolve([]);
                return;
            }
            var result = new Array(thenables.length);
            var remaining = thenables.length;
            for (var i = 0; i < thenables.length; i++) {
                follow(thenables[i], i);
            }
            function follow(t, index) {
                var slave = t instanceof Promise ? t : Promise.resolve(t);
                slave.done(function (v) {
                    result[index] = v;
                    remaining--;
                    if (remaining === 0) {
                        resolve(result);
                    }
                }, function (reason) { return reject(reason); });
            }
        });
    };
    /**
     * Return a promise that resolves to the fulfillment or rejection of the
     * first input promise that resolves.
     * When passing an empty array, the promise will never resolve.
     *
     * @param thenables Array of values or promises for them
     * @return promise that resolves to first resolved input promise
     */
    Promise.race = function (thenables) {
        return new Promise(function (resolve, reject) {
            util_1.assert(Array.isArray(thenables), "thenables must be an Array");
            for (var i = 0; i < thenables.length; i++) {
                var t = thenables[i];
                var slave = t instanceof Promise ? t : Promise.resolve(t);
                Promise.resolve(slave).done(resolve, reject);
            }
        });
    };
    /**
     * Create tuple of a promise and its resolve and reject functions.
     *
     * It is generally better (and slightly faster) to use the Promise
     * constructor to create a promise, as that will also catch any exception
     * thrown while running the resolver.
     *
     * A Deferred can be useful in some scenarios though, e.g. when working with
     * timers, protocol request/response pairs, etc.
     *
     * @return Deferred object, containing unresolved promise and its
     *         resolve/reject functions
     */
    Promise.defer = function () {
        var resolve;
        var reject;
        var p = new Promise(function (res, rej) {
            resolve = res;
            reject = rej;
        });
        return {
            promise: p,
            reject: reject,
            resolve: resolve,
        };
    };
    /**
     * Create a promise that resolves to the given value (or promise for a
     * value) after `ms` milliseconds. The timer will start when the given value
     * is resolved.
     * If the input value is a rejected promise, the resulting promise is also
     * rejected, without waiting for the timer.
     *
     * @param value Value or promise for value to be delayed
     * @param ms Number of milliseconds to wait before resolving
     * @return Promise that fulfills `ms` milliseconds after given (promise for)
     *         value is fulfilled
     */
    Promise.delay = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        if (arguments[1] === undefined) {
            // delay(ms)
            var ms_1 = arguments[0];
            return new Promise(function (resolve) {
                setTimeout(resolve, ms_1);
            });
        }
        // delay(value, ms)
        return Promise.resolve(arguments[0]).delay(arguments[1]);
    };
    /**
     * Enable or disable long stack trace tracking on promises.
     *
     * This allows tracing a promise chain through the various asynchronous
     * actions in a program. For example, when a promise is rejected, the last
     * few locations of any preceding promises are included in the error's stack
     * trace.
     *
     * Note: it is possible to enable/disable long tracing at runtime.
     *
     * When chaining off of a promise that was created while tracing was enabled
     * (e.g. through `.then()`), all children will also have long traces, even
     * when tracing is turned off. This allows to trace just some promise paths.
     *
     * Tracing is disabled by default as it incurs a memory and performance
     * overhead, although it's still faster with tracing than some major
     * promise libraries without tracing, so don't worry too much about it.
     *
     * @param enable Set to true to enable long traces, false to disable
     */
    Promise.setLongTraces = function (enable) {
        longTraces = enable;
    };
    /**
     * Set trace function that is called for internal state changes of a
     * promise.
     * Call with `undefined` or `null` to disable such tracing (this is the
     * default).
     *
     * @param tracer Callback called for various stages during lifetime of a promise
     */
    Promise.setTracer = function (tracer) {
        if (typeof tracer === "function") {
            trace = tracer;
        }
        else {
            trace = undefined;
        }
    };
    /**
     * Recursively flush the async callback queue until all `.then()` and
     * `.done()` callbacks for fulfilled and rejected Promises have been called.
     * Useful in e.g. unit tests to advance program state to the next 'tick'.
     *
     * Note that if e.g. `.done()` encounters a rejected promise, `flush()` will
     * immediately throw an error (e.g. `UnhandledRejectionError`).
     * It is safe to call `flush()` again afterwards, but it will also be called
     * automatically by the async queue on the next 'real' tick.
     *
     * It is an error to call `flush()` while it is already running (e.g. from
     * a `.then()` callback).
     */
    Promise.flush = function () {
        async_1.default.flush();
    };
    Promise.prototype._setSource = function (source) {
        if (!this._trace || !source._trace) {
            return;
        }
        this._trace.setSource(source._trace);
    };
    Promise.prototype._resolve = function (x) {
        // 2.1.2.1 When fulfilled, a promise must not transition to any other state.
        // 2.1.3.1 When rejected, a promise must not transition to any other state.
        util_1.assert(this._state === 0 /* Pending */);
        if (!x) {
            // Shortcut for falsy values, most notably void-Promises
            // 2.3.4: If `x` is not an object or function, fulfill `promise` with `x`
            this._fulfill(x);
            return;
        }
        // 2.3.1: If promise and x refer to the same object, reject promise with a TypeError as the reason.
        if (this === x) {
            this._reject(new TypeError("cannot resolve Promise to self"));
            return;
        }
        // 2.3.2: If `x` is a promise, adopt its state
        if (x instanceof Promise) {
            x._setSource(this);
            if (x._state === 0 /* Pending */) {
                // 2.3.2.1: If `x` is pending, `promise` must remain pending until `x` is fulfilled or rejected.
                this._followPromise(x);
            }
            else if (x._state === 1 /* Fulfilled */) {
                // 2.3.2.2: If/when `x` is fulfilled, fulfill `promise` with the same value.
                this._fulfill(x._result);
            }
            else {
                // 2.3.2.3: If/when `x` is rejected, reject `promise` with the same reason.
                this._reject(x._result);
            }
            return;
        }
        // 2.3.3: Otherwise, if `x` is an object or function,
        if (typeof x === "object" || typeof x === "function") {
            // 2.3.3.1: Let `then` be `x.then`
            var then = this._tryGetThen(x);
            // 2.3.3.2: If retrieving the property `x.then` results in a thrown
            // exception `e`, reject `promise` with `e` as the reason.
            if (then === getThenError) {
                this._reject(wrapNonError(getThenError.error));
                return;
            }
            // 2.3.3.3: If `then` is a function, call it with `x` as `this`,
            //          first argument `resolvePromise`, and second argument `rejectPromise`
            if (typeof then === "function") {
                this._followThenable(x, then);
                return;
            }
            // 2.3.3.4: If `then` is not a function, fulfill promise with `x`
        }
        // 2.3.4: If `x` is not an object or function, fulfill `promise` with `x`
        this._fulfill(x);
    };
    Promise.prototype._tryGetThen = function (x) {
        try {
            // 2.3.3.1: Let `then` be `x.then`
            var then = x.then;
            return then;
        }
        catch (e) {
            // 2.3.3.2: If retrieving the property `x.then` results in a thrown
            // exception `e`, reject `promise` with `e` as the reason.
            getThenError.error = e;
            return getThenError;
        }
    };
    Promise.prototype._fulfill = function (value) {
        // 2.1.2.1 When fulfilled, a promise must not transition to any other state.
        // 2.1.3.1 When rejected, a promise must not transition to any other state.
        util_1.assert(this._state === 0 /* Pending */);
        trace && trace(this, "_fulfill(" + typeof value + ")");
        // 2.1.2.2 When fulfilled, a promise must have a value, which must not change.
        this._state = 1 /* Fulfilled */;
        this._result = value;
        this._flush();
    };
    Promise.prototype._reject = function (reason) {
        var _this = this;
        // 2.1.2.1 When fulfilled, a promise must not transition to any other state.
        // 2.1.3.1 When rejected, a promise must not transition to any other state.
        util_1.assert(this._state === 0 /* Pending */);
        trace && trace(this, "_reject(" + reason + ")");
        // 2.1.3.2 When rejected, a promise must have a reason, which must not change.
        this._state = 2 /* Rejected */;
        this._result = reason;
        if (this._trace && this._result instanceof Error && !this._result.trace) {
            this._result.trace = this._trace;
            // TODO: Meh, this always accesses '.stack', which is supposed to be expensive
            var originalStack = this._result.stack;
            // Stack may be undefined if e.g. a Stack Overflow occurred
            if (originalStack) {
                Object.defineProperty(this._result, "stack", {
                    enumerable: false,
                    get: function () { return originalStack + "\n  from Promise at:\n" + _this._trace.inspect(); },
                });
            }
        }
        this._flush();
    };
    Promise.prototype._followPromise = function (slave) {
        // 2.1.2.1 When fulfilled, a promise must not transition to any other state.
        // 2.1.3.1 When rejected, a promise must not transition to any other state.
        util_1.assert(this._state === 0 /* Pending */);
        trace && trace(this, "_follow([Promise " + slave._id + "])");
        slave._enqueue(undefined, undefined, this, undefined);
    };
    Promise.prototype._followThenable = function (slave, then) {
        var _this = this;
        // 2.1.2.1 When fulfilled, a promise must not transition to any other state.
        // 2.1.3.1 When rejected, a promise must not transition to any other state.
        util_1.assert(this._state === 0 /* Pending */);
        trace && trace(this, "_follow([Thenable])");
        var called = false;
        try {
            // 2.3.3.3: If `then` is a function, call it with `x` as `this`,
            //          first argument `resolvePromise`, and second argument `rejectPromise`
            then.call(slave, function (y) {
                if (called) {
                    // 2.3.3.3.3: If both `resolvePromise` and `rejectPromise` are called,
                    // or multiple calls to the same argument are made, the first call
                    // takes precedence, and any further calls are ignored.
                    return;
                }
                // 2.3.3.3.1: If/when `resolvePromise` is called with value `y`,
                // run `[[Resolve]](promise, y)`
                called = true;
                _this._resolve(y);
            }, function (r) {
                if (called) {
                    // 2.3.3.3.3: If both `resolvePromise` and `rejectPromise` are called,
                    // or multiple calls to the same argument are made, the first call
                    // takes precedence, and any further calls are ignored.
                    return;
                }
                // 2.3.3.3.2: If/when `rejectPromise` is called with reason `r`,
                // reject `promise` with `r`
                called = true;
                _this._reject(wrapNonError(r));
            });
        }
        catch (e) {
            // 2.3.3.3.4: If calling `then` throws an exception `e`,
            // 2.3.3.3.4.1: If `resolvePromise` or `rejectPromise` have been called, ignore it.
            if (!called) {
                // 2.3.3.3.4.2: Otherwise, reject `promise` with `e` as the reason.
                called = true;
                this._reject(wrapNonError(e));
            }
        }
    };
    Promise.prototype._enqueue = function (onFulfilled, onRejected, slave, done) {
        var h = {
            promise: this,
            onFulfilled: onFulfilled,
            onRejected: onRejected,
            slave: slave,
            done: done,
        };
        if (this._state !== 0 /* Pending */) {
            async_1.default.enqueue(Promise._unwrapper, h);
        }
        else {
            if (!this._handlers) {
                this._handlers = [h];
            }
            else {
                var i = this._handlers.length;
                this._handlers[i] = h;
            }
        }
    };
    /**
     * Schedule any pending .then()/.done() callbacks and follower-promises to
     * be called/resolved.
     * Clears our queue, any callbacks/followers attached after this will be
     * scheduled without going through our handlers queue.
     */
    Promise.prototype._flush = function () {
        if (!this._handlers) {
            return;
        }
        var i = 0;
        var h = this._handlers;
        var l = h.length;
        this._handlers = undefined;
        while (i < l) {
            // Note: we enqueue every single callback/follower separately,
            // because e.g. .done() might throw and we need to ensure we can
            // continue after that. async handles that for us.
            // And because the queue needs to be processed in-order, we can't
            // 'filter' the non-callback operations out either.
            async_1.default.enqueue(Promise._unwrapper, h[i++]);
        }
    };
    /**
     * 'Unwrap' a promise handler, i.e. call a .then()/.done() callback, or
     * resolve a promise that's following us.
     * @param handler The handler being processed
     */
    Promise.prototype._unwrap = function (handler) {
        var callback = this._state === 1 /* Fulfilled */ ? handler.onFulfilled : handler.onRejected;
        if (handler.done) {
            // Unwrap .done() callbacks
            trace && trace(this, "_unwrap()");
            if (typeof callback !== "function") {
                // No callback: if we ended in a rejection, throw it, otherwise
                // all was good.
                if (this._state === 2 /* Rejected */) {
                    var unhandled = new UnhandledRejectionError(this._result, handler.done);
                    // TODO Allow intercepting these
                    // Leave the comment after the throw: may show up in source line in node
                    throw unhandled; // Unhandled exception caught by .done()
                }
                return;
            }
            util_1.assert(!unwrappingPromise);
            unwrappingPromise = this;
            try {
                var result = callback(this._result);
                if (result) {
                    // May be a thenable, need to start following it...
                    var p = (result instanceof Promise) ? result : Promise.resolve(result);
                    p.done(); // Ensure it throws as soon as it's rejected
                }
                unwrappingPromise = undefined;
            }
            catch (e) {
                unwrappingPromise = undefined;
                // Wrap in UnhandledRejectionError
                var unhandled = new UnhandledRejectionError(e, handler.done);
                // TODO Allow intercepting these
                // Leave the comment after the throw: may show up in source line in node
                throw unhandled; // Unhandled exception caught by .done()
            }
            return;
        }
        // Unwrap .then() callbacks, or resolve 'parent' promise
        //
        // Three scenarios are handled here:
        // 1. An onFulfilled callback was registered and promise is fulfilled,
        //    or onRejected callback was registered and promise is rejected
        //    -> callback is a function, slave is the promise that was returned
        //       from the .then() call, so resolve slave with outcome of callback
        // 2. An onFulfilled callback was registered but promise is rejected,
        //    or onRejected callback was registered but promise is fulfilled
        //    -> callback is not a function (typically `undefined`), slave is
        //       promise that was returned from the .then() call, so resolve it
        //       with our own result (thereby 'skipping' the .then())
        // 3. Another promise attached itself on our 'callback queue' to be
        //    resolved when we do (i.e. its fate is determined by us)
        //    -> callbacks will both be undefined, slave is that other promise
        //       that wants to be resolved with our result
        var slave = handler.slave;
        trace && trace(this, "_unwrap(" + slave._id + ")");
        if (typeof callback === "function") {
            // Case 1
            util_1.assert(!unwrappingPromise);
            unwrappingPromise = slave;
            try {
                // 2.2.5 handlers must be called as functions
                slave._resolve(callback(this._result));
            }
            catch (e) {
                slave._reject(wrapNonError(e));
            }
            unwrappingPromise = undefined;
        }
        else {
            // Case 2 and 3
            if (this._state === 1 /* Fulfilled */) {
                slave._fulfill(this._result);
            }
            else {
                slave._reject(this._result);
            }
        }
    };
    /**
     * Helper for unwrapping promise handler.
     * It's not a closure so it's cheap to schedule, and because it directly
     * calls the _unwrap() method on a promise, it's (way) faster than having to
     * use e.g. .call().
     * @param handler The handler being processed
     */
    Promise._unwrapper = function (handler) {
        handler.promise._unwrap(handler);
    };
    return Promise;
}());
exports.Promise = Promise;
exports.default = Promise;
//# sourceMappingURL=Promise.js.map