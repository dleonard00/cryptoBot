"use strict";
/**
 * Helper class for capturing stack traces.
 *
 * Copyright (C) 2015 Martin Poelstra
 * License: MIT
 */
Object.defineProperty(exports, "__esModule", { value: true });
// TODO:
// - test/make it work in non-V8
var Stack_1 = require("./Stack");
/**
 * Stack trace container with optional source traces.
 *
 * Typically used for capturing traces across asynchronous calls (e.g.
 * with Promises or Events).
 */
var Trace = /** @class */ (function () {
    function Trace(ignoreUntil) {
        if (ignoreUntil === void 0) { ignoreUntil = Trace; }
        this.stack = new Stack_1.default(ignoreUntil);
    }
    /**
     * Assign another Trace as the source of this Trace.
     *
     * Note: the stack of `source` is copied to this Trace, in order to allow
     * truncating the trace length to `Trace.traceLimit` to prevent memory
     * exhaustion on e.g. recursive traces.
     *
     * @param source Trace to use as source.
     */
    Trace.prototype.setSource = function (source) {
        if (!source.sources) {
            this.sources = [source.stack];
        }
        else {
            this.sources = source.sources.concat(source.stack);
            if (this.sources.length > Trace.traceLimit) {
                this.sources = this.sources.slice(0, Trace.traceLimit);
            }
        }
    };
    Trace.prototype.inspect = function () {
        var result = this.stack.inspect();
        if (this.sources) {
            for (var i = this.sources.length - 1; i >= 0; i--) {
                result += "\n  from previous:\n" + this.sources[i].inspect();
            }
        }
        return result;
    };
    Trace.traceLimit = 10;
    return Trace;
}());
exports.default = Trace;
//# sourceMappingURL=Trace.js.map